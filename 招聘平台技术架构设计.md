# 招聘平台技术架构设计

## 1. 系统架构概述

### 1.1 整体架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端应用层    │    │    API网关层    │    │   业务服务层    │
│                 │    │                 │    │                 │
│ • Web端        │◄──►│ • 负载均衡      │◄──►│ • 用户服务      │
│ • H5端         │    │ • 路由转发      │    │ • 职位服务      │
│ • 小程序端     │    │ • 限流熔断      │    │ • 简历服务      │
│ • App端        │    │ • 认证授权      │    │ • 匹配服务      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │                       │
                                ▼                       ▼
                       ┌─────────────────┐    ┌─────────────────┐
                       │   数据存储层    │    │   基础设施层    │
                       │                 │    │                 │
                       │ • PostgreSQL   │    │ • Redis缓存     │
                       │ • MongoDB      │    │ • ElasticSearch │
                       │ • Redis        │    │ • 消息队列      │
                       │ • MinIO        │    │ • 监控日志      │
                       └─────────────────┘    └─────────────────┘
```

### 1.2 技术栈选择

#### 1.2.1 前端技术栈
- **框架**: UniApp (支持多端发布)
- **UI组件**: uView UI
- **状态管理**: Pinia
- **构建工具**: Vite
- **包管理**: npm/yarn

#### 1.2.2 后端技术栈
- **框架**: FastAPI (Python 3.9+)
- **数据库**: PostgreSQL 14+
- **缓存**: Redis 6+
- **搜索引擎**: Elasticsearch 8+
- **消息队列**: Celery + Redis
- **文件存储**: MinIO

#### 1.2.3 部署运维
- **容器化**: Docker + Docker Compose
- **反向代理**: Nginx
- **监控**: Prometheus + Grafana
- **日志**: ELK Stack
- **CI/CD**: GitLab CI

## 2. 前端架构设计

### 2.1 UniApp多端适配

#### 2.1.1 目录结构
```
src/
├── pages/                 # 页面文件
│   ├── index/            # 首页
│   ├── job/              # 职位相关
│   ├── resume/           # 简历相关
│   ├── company/          # 企业相关
│   └── user/             # 用户中心
├── components/            # 公共组件
│   ├── common/           # 通用组件
│   ├── business/         # 业务组件
│   └── form/             # 表单组件
├── store/                 # 状态管理
│   ├── user.js           # 用户状态
│   ├── job.js            # 职位状态
│   └── app.js            # 应用状态
├── utils/                 # 工具函数
├── api/                   # API接口
└── static/                # 静态资源
```

#### 2.1.2 多端适配策略
```javascript
// 平台判断
const platform = uni.getSystemInfoSync().platform;

// 条件编译
// #ifdef H5
// H5端特有代码
// #endif

// #ifdef MP-WEIXIN
// 微信小程序特有代码
// #endif

// #ifdef APP-PLUS
// App端特有代码
// #endif
```

### 2.2 状态管理设计

#### 2.2.1 Pinia Store结构
```javascript
// stores/user.js
export const useUserStore = defineStore('user', {
  state: () => ({
    userInfo: null,
    token: null,
    permissions: []
  }),
  
  getters: {
    isLoggedIn: (state) => !!state.token,
    hasPermission: (state) => (permission) => 
      state.permissions.includes(permission)
  },
  
  actions: {
    async login(credentials) {
      // 登录逻辑
    },
    async logout() {
      // 登出逻辑
    }
  }
});
```

## 3. 后端架构设计

### 3.1 FastAPI应用结构

#### 3.1.1 项目目录结构
```
backend/
├── app/
│   ├── __init__.py
│   ├── main.py              # 应用入口
│   ├── core/                # 核心配置
│   │   ├── config.py        # 配置管理
│   │   ├── security.py      # 安全认证
│   │   └── database.py      # 数据库配置
│   ├── api/                 # API路由
│   │   ├── v1/              # API版本
│   │   │   ├── auth.py      # 认证接口
│   │   │   ├── users.py     # 用户接口
│   │   │   ├── jobs.py      # 职位接口
│   │   │   └── resumes.py   # 简历接口
│   │   └── deps.py          # 依赖注入
│   ├── models/              # 数据模型
│   ├── schemas/             # 数据验证
│   ├── services/            # 业务逻辑
│   └── utils/               # 工具函数
├── alembic/                 # 数据库迁移
├── tests/                   # 测试文件
├── requirements.txt          # 依赖包
└── docker-compose.yml       # Docker配置
```

#### 3.1.2 主应用配置
```python
# app/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.api.v1 import auth, users, jobs, resumes
from app.core.config import settings

app = FastAPI(
    title="智聘招聘平台",
    description="智能招聘服务平台API",
    version="1.0.0"
)

# CORS配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_HOSTS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 注册路由
app.include_router(auth.router, prefix="/api/v1/auth", tags=["认证"])
app.include_router(users.router, prefix="/api/v1/users", tags=["用户"])
app.include_router(jobs.router, prefix="/api/v1/jobs", tags=["职位"])
app.include_router(resumes.router, prefix="/api/v1/resumes", tags=["简历"])
```

### 3.2 数据库设计

#### 3.2.1 核心数据表

**用户表 (users)**
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    phone VARCHAR(20),
    password_hash VARCHAR(255) NOT NULL,
    user_type VARCHAR(20) NOT NULL, -- 'jobseeker', 'company', 'admin'
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**企业表 (companies)**
```sql
CREATE TABLE companies (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    company_name VARCHAR(100) NOT NULL,
    industry VARCHAR(50),
    company_size VARCHAR(20),
    company_type VARCHAR(20),
    description TEXT,
    logo_url VARCHAR(255),
    website VARCHAR(255),
    address TEXT,
    verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**职位表 (jobs)**
```sql
CREATE TABLE jobs (
    id SERIAL PRIMARY KEY,
    company_id INTEGER REFERENCES companies(id),
    title VARCHAR(100) NOT NULL,
    description TEXT,
    requirements TEXT,
    salary_min INTEGER,
    salary_max INTEGER,
    salary_type VARCHAR(20), -- 'monthly', 'yearly'
    location VARCHAR(100),
    job_type VARCHAR(20), -- 'fulltime', 'parttime', 'intern'
    experience_level VARCHAR(20),
    education_level VARCHAR(20),
    status VARCHAR(20) DEFAULT 'active',
    views_count INTEGER DEFAULT 0,
    applications_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**简历表 (resumes)**
```sql
CREATE TABLE resumes (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    title VARCHAR(100),
    summary TEXT,
    experience_years INTEGER,
    education_level VARCHAR(20),
    expected_salary INTEGER,
    expected_location VARCHAR(100),
    skills TEXT[],
    work_experience JSONB,
    education JSONB,
    projects JSONB,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.2 数据模型定义
```python
# app/models/user.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from sqlalchemy.sql import func
from app.core.database import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)
    phone = Column(String(20))
    password_hash = Column(String(255), nullable=False)
    user_type = Column(String(20), nullable=False)
    status = Column(String(20), default="active")
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
```

### 3.3 API接口设计

#### 3.3.1 认证接口
```python
# app/api/v1/auth.py
from fastapi import APIRouter, Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer
from app.schemas.auth import LoginRequest, LoginResponse
from app.services.auth import AuthService

router = APIRouter()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

@router.post("/login", response_model=LoginResponse)
async def login(request: LoginRequest):
    """用户登录"""
    auth_service = AuthService()
    result = await auth_service.authenticate_user(
        request.username, request.password
    )
    if not result:
        raise HTTPException(status_code=401, detail="用户名或密码错误")
    return result

@router.post("/refresh")
async def refresh_token(token: str = Depends(oauth2_scheme)):
    """刷新访问令牌"""
    auth_service = AuthService()
    return await auth_service.refresh_token(token)
```

#### 3.3.2 职位接口
```python
# app/api/v1/jobs.py
from fastapi import APIRouter, Depends, Query
from app.schemas.job import JobCreate, JobUpdate, JobResponse
from app.services.job import JobService
from app.api.deps import get_current_user

router = APIRouter()

@router.get("/", response_model=list[JobResponse])
async def get_jobs(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
    keyword: str = None,
    location: str = None,
    job_type: str = None
):
    """获取职位列表"""
    job_service = JobService()
    return await job_service.get_jobs(skip, limit, keyword, location, job_type)

@router.post("/", response_model=JobResponse)
async def create_job(
    job: JobCreate,
    current_user = Depends(get_current_user)
):
    """创建职位"""
    job_service = JobService()
    return await job_service.create_job(job, current_user.id)
```

## 4. 智能匹配算法

### 4.1 匹配算法架构

#### 4.1.1 算法流程
```
职位发布 → 简历收集 → 特征提取 → 相似度计算 → 排序推荐
    ↓           ↓         ↓         ↓         ↓
职位解析    简历解析    向量化    算法匹配    结果输出
```

#### 4.1.2 核心算法
```python
# app/services/matching.py
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

class MatchingService:
    def __init__(self):
        self.vectorizer = TfidfVectorizer(
            max_features=1000,
            stop_words='english',
            ngram_range=(1, 2)
        )
    
    async def calculate_job_resume_similarity(self, job, resume):
        """计算职位和简历的相似度"""
        # 文本特征提取
        job_text = f"{job.title} {job.description} {job.requirements}"
        resume_text = f"{resume.title} {resume.summary} {' '.join(resume.skills)}"
        
        # 向量化
        texts = [job_text, resume_text]
        vectors = self.vectorizer.fit_transform(texts)
        
        # 计算相似度
        similarity = cosine_similarity(vectors[0:1], vectors[1:2])[0][0]
        
        # 权重调整
        weighted_similarity = self._apply_weights(similarity, job, resume)
        
        return weighted_similarity
    
    def _apply_weights(self, base_similarity, job, resume):
        """应用权重调整"""
        # 经验匹配权重
        exp_weight = self._calculate_experience_weight(job, resume)
        
        # 技能匹配权重
        skill_weight = self._calculate_skill_weight(job, resume)
        
        # 地理位置权重
        location_weight = self._calculate_location_weight(job, resume)
        
        # 综合权重
        final_similarity = base_similarity * 0.4 + exp_weight * 0.3 + \
                          skill_weight * 0.2 + location_weight * 0.1
        
        return final_similarity
```

### 4.2 推荐系统

#### 4.2.1 协同过滤推荐
```python
# app/services/recommendation.py
class RecommendationService:
    async def get_personalized_jobs(self, user_id, limit=10):
        """获取个性化职位推荐"""
        # 获取用户行为数据
        user_behavior = await self._get_user_behavior(user_id)
        
        # 基于内容的推荐
        content_based = await self._content_based_recommendation(user_behavior)
        
        # 协同过滤推荐
        collaborative = await self._collaborative_filtering(user_id)
        
        # 混合推荐
        recommendations = self._hybrid_recommendation(
            content_based, collaborative
        )
        
        return recommendations[:limit]
    
    async def _content_based_recommendation(self, user_behavior):
        """基于内容的推荐"""
        # 分析用户偏好
        preferences = self._analyze_user_preferences(user_behavior)
        
        # 匹配相似职位
        similar_jobs = await self._find_similar_jobs(preferences)
        
        return similar_jobs
    
    async def _collaborative_filtering(self, user_id):
        """协同过滤推荐"""
        # 找到相似用户
        similar_users = await self._find_similar_users(user_id)
        
        # 推荐相似用户喜欢的职位
        recommendations = await self._get_user_liked_jobs(similar_users)
        
        return recommendations
```

## 5. 缓存策略

### 5.1 Redis缓存设计

#### 5.1.1 缓存结构
```python
# app/core/cache.py
import redis
from app.core.config import settings

class RedisCache:
    def __init__(self):
        self.redis = redis.Redis(
            host=settings.REDIS_HOST,
            port=settings.REDIS_PORT,
            db=settings.REDIS_DB,
            decode_responses=True
        )
    
    async def cache_job_list(self, key, jobs, expire=3600):
        """缓存职位列表"""
        self.redis.setex(key, expire, jobs)
    
    async def get_cached_jobs(self, key):
        """获取缓存的职位列表"""
        return self.redis.get(key)
    
    async def invalidate_job_cache(self):
        """清除职位相关缓存"""
        pattern = "jobs:*"
        keys = self.redis.keys(pattern)
        if keys:
            self.redis.delete(*keys)
```

### 5.2 缓存策略

#### 5.2.1 缓存层次
- **L1缓存**: 应用内存缓存 (TTL: 5分钟)
- **L2缓存**: Redis缓存 (TTL: 1小时)
- **L3缓存**: 数据库查询

#### 5.2.2 缓存更新策略
- **写后更新**: 数据更新后立即更新缓存
- **定时刷新**: 定时刷新热点数据
- **失效策略**: 设置合理的TTL时间

## 6. 安全设计

### 6.1 认证授权

#### 6.1.1 JWT认证
```python
# app/core/security.py
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext

class SecurityService:
    def __init__(self):
        self.pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
        self.secret_key = settings.SECRET_KEY
        self.algorithm = "HS256"
        self.access_token_expire_minutes = 30
    
    def create_access_token(self, data: dict):
        """创建访问令牌"""
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(
            minutes=self.access_token_expire_minutes
        )
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        return encoded_jwt
    
    def verify_token(self, token: str):
        """验证令牌"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except JWTError:
            return None
```

### 6.2 数据安全

#### 6.2.1 数据加密
- **传输加密**: HTTPS/TLS 1.3
- **存储加密**: 敏感数据AES-256加密
- **密码哈希**: bcrypt算法

#### 6.2.2 访问控制
- **角色权限**: RBAC权限模型
- **API限流**: 基于Redis的限流器
- **SQL注入防护**: 参数化查询

## 7. 部署架构

### 7.1 Docker容器化

#### 7.1.1 Docker Compose配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/recruitment
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis
    volumes:
      - ./backend:/app
      - /app/node_modules

  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    volumes:
      - ./frontend:/app
      - /app/node_modules

  db:
    image: postgres:14
    environment:
      - POSTGRES_DB=recruitment
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl

volumes:
  postgres_data:
```

### 7.2 监控日志

#### 7.2.1 监控指标
- **系统指标**: CPU、内存、磁盘、网络
- **应用指标**: 响应时间、错误率、吞吐量
- **业务指标**: 用户活跃度、职位发布数、匹配成功率

#### 7.2.2 日志收集
- **应用日志**: 结构化JSON日志
- **访问日志**: Nginx访问日志
- **错误日志**: 错误堆栈和上下文信息

## 8. 性能优化

### 8.1 数据库优化

#### 8.1.1 索引优化
```sql
-- 职位表索引
CREATE INDEX idx_jobs_company_id ON jobs(company_id);
CREATE INDEX idx_jobs_status ON jobs(status);
CREATE INDEX idx_jobs_location ON jobs(location);
CREATE INDEX idx_jobs_created_at ON jobs(created_at);

-- 复合索引
CREATE INDEX idx_jobs_search ON jobs(status, location, job_type);
```

#### 8.1.2 查询优化
- **分页查询**: 使用游标分页
- **连接查询**: 避免N+1查询问题
- **批量操作**: 批量插入和更新

### 8.2 前端优化

#### 8.2.1 性能优化策略
- **代码分割**: 按路由和组件分割代码
- **懒加载**: 图片和组件懒加载
- **缓存策略**: 合理的缓存策略
- **CDN加速**: 静态资源CDN分发

## 9. 扩展性设计

### 9.1 微服务架构

#### 9.1.1 服务拆分
- **用户服务**: 用户管理、认证授权
- **职位服务**: 职位管理、搜索推荐
- **简历服务**: 简历管理、匹配算法
- **通知服务**: 消息推送、邮件短信

#### 9.1.2 服务通信
- **同步通信**: RESTful API
- **异步通信**: 消息队列
- **服务发现**: Consul或Eureka

### 9.2 水平扩展

#### 9.2.1 负载均衡
- **应用层**: Nginx负载均衡
- **数据库层**: 读写分离、分库分表
- **缓存层**: Redis集群

#### 9.2.2 弹性伸缩
- **自动扩缩容**: 基于CPU和内存使用率
- **容器编排**: Kubernetes集群管理
- **云原生**: 云服务弹性伸缩

## 10. 总结

本技术架构设计采用现代化的技术栈和架构模式，具有以下特点：

### 10.1 技术优势
- **高性能**: FastAPI异步框架，Redis缓存，数据库优化
- **高可用**: 微服务架构，负载均衡，故障恢复
- **高扩展**: 容器化部署，水平扩展，云原生架构

### 10.2 架构特点
- **前后端分离**: 清晰的接口定义和职责分离
- **多端适配**: UniApp支持多端发布
- **智能算法**: AI驱动的匹配和推荐系统

### 10.3 实施建议
- **分阶段实施**: 先核心功能，后扩展功能
- **持续优化**: 性能监控和持续优化
- **安全第一**: 完善的安全防护措施